cpu-sched-multi

1.

$ ./multi.py -n 1 -L a:30:200

共耗费 30 个时间单位

2.

$ ./multi.py -n 1 -L a:30:200 -M 300

前 10 个时间单位预热, 后 20 个时间单位根据预热仅需 10 个时间单位, 共耗费 30 个时间单位

3.

$ ./multi.py -n 1 -L a:30:200 -M 300 -T

完成预热后每次时间减少 2

4.

$ ./multi.py -n 1 -L a:30:200 -M 300 -C

9 号时间片 (第 10 个) 之后完成预热

5.

$ ./multi.py -n 2 -L a:100:100,b:100:50,c:100:50

由于 CPU 10 个时间单位进行一次切换, 所以 CPU 0 和 1 的执行顺序如下

0 a c b a c b a c b a c b
1 b a c b a c b a c b a c

每次 a 进入一个 CPU 都会占据全部的 cache, 所以全部的调度都会预热失败, 故每个进程的执行时间与与预期时间相同, 共有 2 个 CPU, 故总的执行时间为 (100 + 100 + 100) / 2 = 150

打开 -C 后发现完成预热的进程与正在运行的进程总是不同

6.

$ ./multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -A a:0,b:1,c:1

a 在 CPU 0 上单独运行, 总时长为 (10 + 90 / 2) = 55
b,c 在 CPU 1 上交替运行, 都可以完成预热, 总时长为 (10 + 90 / 2) * 2 = 110

故总计时长为 110

这样子会产生更好的 CPU 亲和度

由于 a 需要占据 100 的 cache, 故其他进程的与 a 在同一个 CPU上运行时会相互清空 cache, 导致效率下降

7.

$ ./multi.py -n 1 -L a:100:100,b:100:100,c:100:100 -M 50

Finished time 300

$ ./multi.py -n 2 -L a:100:100,b:100:100,c:100:100 -M 50

Finished time 150

$ ./multi.py -n 3 -L a:100:100,b:100:100,c:100:100 -M 50

Finished time 100

$ ./multi.py -n 1 -L a:100:100,b:100:100,c:100:100 -M 100

Finished time 300

$ ./multi.py -n 2 -L a:100:100,b:100:100,c:100:100 -M 100

Finished time 150

$ ./multi.py -n 3 -L a:100:100,b:100:100,c:100:100 -M 100

Finished time 55

$ ./multi.py -n 2 -L a:100:100,b:100:100,c:100:100 -M 300

Finished time 90

$ ./multi.py -n 3 -L a:100:100,b:100:100,c:100:100 -M 200

Finished time 55

对于 2 CPU 而言, 当 cache 大小为 300 时, 此时可容纳全部的进程的缓存, 发生超线性加速; 对于 3 CPU 而言, 当 cache 大小为 100 时, 此时可容纳全部的进程的缓存, 发生超线性加速

8.

$ ./multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -p

此选项将 a和c 安排在 CPU0 上, 将 b 安排在 CPU1 上, 随后 a 和 c 交替运行, b 单独运行; 当 b 运行完成后, 将空闲的 a 交给 CPU1 运行

设置 -P 的窥探时间, 当 b 恰好完成时窥探, 可以使效率提升, 否则必须在进行中断时窥探, 效率会降低

9.
开摆
